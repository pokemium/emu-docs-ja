# Libretorコアの開発 ~Libretro APIの実装~

<pre>
Note: 

この記事は<a href="developing-cores.md">Libretorコアの開発</a>からAPIの一覧部分を抜き出したものです。
</pre>

libretro APIは、RetroArchのソースパッケージにある`libretro.h`に記載されているいくつかの関数で構成されています。

libretro の実装は、`libretro.h` で記述されている関数をすべてエクスポートした動的ロード可能な実行ファイル (`.dll/.so/.dylib`) または静的ライブラリ (`.a/.lib`) にコンパイルする必要があります。

実装はシングルインスタンスであることを前提としていますので、グローバルな状態も許容されます。フロントエンドがこれらの関数を間違った順序で呼び出すと、未定義の動作が発生します。

APIヘッダはC99とC++に対応しています。C99では、bool型と`<stdint.h>`を使用しています。

libretro APIを用いたフロントエンドのプログラムフローは、以下のように表現できます。

## 🧨 起動時

### `retro_api_version()`

この関数は、`libretro.h`で定義されている`RETRO_API_VERSION`を返す必要があります。

この関数は、ABI/APIが不一致であるかどうかを判断するためにフロントエンドによって使用されます。

API に互換性のない変更があった場合は、バージョンが変更されます。`retro_*`構造体への変更や、公開されている関数やその引数への変更は、APIバージョンのバンプ(バージョン更新)を保証します。

### `retro_set_*()`

Libretroはコールバックベースです。フロントエンドはこの段階ですべてのコールバックを設定し、実装側はこれらの関数ポインタをどこかに保存しなければなりません。フロントエンドは、後からこれらを呼び出すことができます。

### `retro_init()`

この関数は一度だけ呼ばれ、実装側にデータ構造を初期化する機会を与えます。

### 環境コールバック

libretroにはビデオ、オーディオ、入力用のコールバックがありますが、環境コールバックと呼ばれるコールバックもあります。

このコールバック(`retro_environment_t`)は、libretroの実装側がAPIの機能にアクセスするための一般的な方法で、独自のシンボルを付けるにはあまりにも不明瞭であると考えられています。

これはABIを壊すことなく拡張することができます。このコールバックは、フロントエンドが与えられたリクエストを認識したかどうかを示す`bool`型の戻り値を持っています。

### `retro_set_controller_port_device()`

デフォルトでは、ゲームパッドが実装に挿入されていると想定されます。

コアがどのタイプの入力デバイスが差し込まれているかに敏感な場合は、フロントエンドがこの関数を呼び出して、特定のプレイヤーに対して使用するデバイスを設定することがあります。

実装側では、可能であればこれを自動検出するようにしてください。

### `retro_get_system_info()`

フロントエンドは通常、実装の名前やバージョン番号など、コアに関する静的に知られている情報を要求します。返された情報は、静的に割り当てられていなければなりません。

### `retro_load_game()`

この関数はコンテンツをロードします。

実装がエミュレータであれば、ゲームのROMイメージ、ゲームエンジンであれば、ゲーム用のパッケージ化されたアップアセットなどが考えられます。

この関数は、ROMがロードされたパスを示す構造体と、すでにロードされたファイルのメモリチャンクを受け取ります。

**libretroでのファイルの読み込みには2つのモードがあります。** ゲームエンジンが ROMイメージがどこからロードされたかのパスを知る必要がある場合、`retro_system_info`の`need_fullpath`フィールドを`true`に設定する必要があります。パスが必要な場合、フロントエンドは `data/size`フィールドにファイルをロードせず、ディスクからファイルをロードするかどうかは実装次第となります。パスには相対パスと絶対パスがありますが、実装では両方のケースをチェックする必要があります。この機能は、ROMイメージが大きすぎて一度にメモリにロードできない場合に有効です。また、コンテンツが多くの小さなファイルで構成されている場合、他のファイルのパスを推論するためにマスターファイルのパスを知る必要がある場合にも便利です。

`need_fullpath`を`false`に設定すると、フロントエンドはあらかじめROMイメージをメモリにロードしておきます。このモードでは、`path`フィールドが非NULLであることは保証されません。ファイルが実際にディスクから読み込まれた場合には有効なパスを指すはずですが、 標準入力などから読み込まれた場合には明確なパスが存在しない可能性があります。可能であれば、`need_fullpath`を`false`に設定することをお勧めします。これにより、ソフトパッチなどの機能が正しく動作するようになります。

### `retro_get_system_av_info()`

この関数は、フロントエンドにゲームの重要なオーディオ/ビデオのプロパティを知らせるものです。

この情報は読み込まれたゲームに依存することがあるため、有効なROMイメージが読み込まれた後にのみ問い合わせが行われます。

FFmpegによる録画は、数時間同期して実行できるように正確な情報に依存しているため、FPSとオーディオサンプリングレートを正確に報告することが重要です。

## 💥 実行時

### `retro_run()`

## 💧 終了時

### `retro_unload_game()`

### `retro_deinit()`

## 🧶 マルチスレッド時の安全性について

libretro API はスレッドの安全性については保証しません。

したがって、コアの開発者は libretroヘッダで宣言された関数がリエントラントではなく、また複数のスレッドから同時に呼び出されても安全ではないと考えるべきです。

コアがマルチスレッドの場合、コアの開発者は libretro APIを呼び出す際のスレッドの安全性について責任を負います。

`retro_run()`の外で、つまりメインスレッドの外で libretro APIコールを行うことは推奨されません。

