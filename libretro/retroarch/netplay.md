# ネット対戦(WIP)

RetroArchでは、インターネット経由で2人目以降のプレイヤーや観客を接続することができます。

RetroArchのネットプレイコードはリプレイをベースにしており、デフォルトの設定では入力遅延のない信頼性の低いネットワークでのネットプレイを実現しています。ネットプレイは最大16人のプレイヤーと多数の観客に対応しています。RetroArchのネットプレイは、次の3つの細かい制約があるものの、完璧な同期を保って動作することが保証されています。

1. コアは`deterministic`であること。
2. コアが操作する入力デバイスは、ゲームパッドとアナログスティックだけであること。
3. コアとロードされたコンテンツの両方が、ホストとクライアントで同一なものであること。

また、ネットプレイを適切に動作させるためには、コアがシリアライズに対応している必要があります。シリアライズに対応していないコアでは、ネットプレイは限定的にしか動作しません。シリアライズに対応することで、よりスムーズな体験ができるようになります。

RetroArchのネットプレイは、ネットワークからの遅延入力を期待し、その遅延入力を巻き戻して再生することで、一貫した状態を得るという仕組みになっています。

ある時点では、すべてのネットプレイクライアントは矛盾した状態にあるかもしれませんが、お互いに遅延データを受信すると、矛盾していた最後の時点に目に見えない形で巻き戻し、新しい入力で再生して、前の状態よりも「正しい」正規の状態に近い新しい状態に遷移します。

どのフレームがどのフレームであるかについて双方が合意している限り、それぞれの入力イベントが常に正しいフレームで起こるので、両者の同期がずれることはありません。

## 仕様

ネットプレイのトランスポートプロトコルはTCPを使用しています。これは信頼性と順番通りの配信が正しい動作のために必須であるためです。

1台のネットプレイサーバが、複数のネットプレイクライアントからの接続を受けることがあります。

ほとんどの場合、サーバとクライアントは同等の参加者ですが、グローバルな同期を必要とする操作では、サーバが正規の参加者となります。

通常の動作では、再生中の各クライアントは、フレームごとに自分のコントローラの入力状態を送信するだけであり、サーバはクライアント間で入力データを転送します。

すべてのクライアントとサーバーは、どのプレイヤーのスロットが使用されているか（つまり、どのコントローラが接続されているか）を認識しており、サーバーはどのクライアントがどのプレイヤーのスロットに対応しているかを認識しています。

すべてのプレイヤーがフレームごとに入力データを順番どおりに送信することが重要であるため、すべてのクライアントはすべてのプレイヤーのフレームカウンタを念頭に置いています。

予想外に低いフレーム数の入力データを受信した場合は無視され、予想外に高いフレーム数の入力データを受信した場合は接続を終了します。

また、すべてのプレイヤーがどのフレームがどのフレームであるかに同意することが重要です。

そのため、最初の接続時に、サーバーは正規のフレームカウントとシリアル化されたセーブステートを与え、クライアントがストリームの途中で参加できるようにします。観戦者は入力データを送ることはありません。

プレイヤーから新しい入力データを受け取ったとき、それが現在実行中のフレームより前であれば、RetroArchは新しい入力データで目立たないように巻き戻して再生し、元のフレームに到達するので、ローカルプレイヤー自身の入力は常に無意識に行われます。

その他のイベントは、サーバのフレームカウンタに連動しており、ほとんどのイベントはサーバのみが行うことができます。例えば、クライアントが観戦からプレイに切り替える場合、単に入力データの送信を開始することはできず、モード変更のリクエストを送信する必要があります。クライアントは、以前のフレームのデータを送信するために巻き戻したり、ローカルのフレーム数がサーバのフレーム数に達するまで入力データの送信を待つ必要があるかもしれません。

特に、リセットやセーブステートのロードは、常にサーバのフレームカウントに同期しているため、サーバのみがコアのリセットやセーブステートのロードを行うことができます。

セーブステートのロードの前の入力は無関係であるため、セーブステートのロードコマンドを受信すると、すべてのフレームカウントは、少なくともサーバーのフレームカウント（該当する場合はローカルのフレームカウントを含む）に更新されます。これは、フレームカウントが、実行フレームあたり1フレーム以上の割合でスキップする唯一の条件です。

## 実装

Netplayは実質的に、リングバッファとして実装されている入力状態のバッファと、いくつかのプリフレームとポストフレームの挙動で構成されています。

RetroArchのNetplayでは、`Self`, `Other`, `Unread` という、3つの重要なロケーションが存在します。

それぞれが、フレームと、そのフレームに対応するステートバッファを参照します。ステートバッファには、そのフレームのセーブステートと、ローカルとリモートの両方のプレーヤーからの入力が含まれます。

`Self`はRetroArchが自分自身の位置を認識しているロケーションで、相手から読み取った位置よりも前か後ろかになります。`Self`は、ステートをロードするためにローカルのフレームカウントが強制的にスキップされる場合を除き、実行されたフレームごとに1フレームの割合で進行します。

`Unread`とは、すべてのプレイヤーのデータが読み込まれていない最初のフレームのことです。通常、`Unread`は`Self`よりも小さいですが、あるクライアントが他のクライアントよりも 他のクライアントよりも先に進むことが可能です。

`Other`は、直近で完全に同期していたロケーションのことです。つまり、`Other-1`は、ローカルとリモートのすべての入力が実行された最後のフレームを指します。同期をとるために`Other`よりも遠くに巻き戻す必要はなく、`Other`は常に`Self`と`Unread`の両方以下です。ステートバッファはリングなので、`Other`は上書きしてはいけない最初のフレームとなります。

サーバーは、複数のクライアントを扱うことができるので、若干ですが複雑な仕事をする必要があります。プレイ中の各コネクションについて、プレイヤーごとの`Unread`フレームを維持し、各プレイヤーの`Unread`フレームのうち最も早いものをグローバル`Unread`フレームとします。

また、サーバーは入力データを転送します。入力データがサーバの現在のフレームよりも前のフレームから受信された場合、サーバは直ちにそれを転送します。

それ以外の場合は、そのフレームに達した時点で転送します。つまり、フレーム`n`の間、サーバーは自分のデータと他のプレイヤーのデータを任意の数だけフレーム`n`に送ることができますが、フレーム`n+1`を送ることはありません。これは、サーバーのクロックが、プレーヤーの反転、プレーヤーの加入・離脱、ステートの保存・読み込みなど、すべての同期関連イベントのアービターであるためです。

TODO

## プロトコル

TODO

## Other features

一般的には、入力レイテンシは望まれないと考えられています。しかし、入力レイテンシも選択肢の一つです。

入力レイテンシの利点は、実際の実行がフレーム数よりも遅れることです。フレーム数に比べて実際の実行が遅れるため、遠隔地のデータが利用できることが多くなり、巻き戻しの頻度もコストも少なくて済みます。

ステートバッファには、入力遅延が有効な場合に使用される`run`というロケーションが追加されています。この場合、`self`は入力が読み込まれている場所を指し、`run`は実際に実行されているフレームを指します。`run`は純粋にローカルです。
